********************************************************************************
CS525: Advanced Database Organization
Fall 2021 | Group 22
Isa Muradli           (imuradli@hawk.iit.edu)       (Section 01)
Andrew Petravicius    (apetravicius@hawk.iit.edu)   (Section 01)
Christopher Sherman   (csherman1@hawk.iit.edu)      (Section 02)
********************************************************************************

1. Scripts
********************************************************************************

To build and run the given test executable "test_assign2_1" using
"test_assign2_1.c", use the following commands:

$ make
$ ./test_assign2_1

To build and run the original test file created by CS 525 Fall 2021 Group 22
for testing our hashtable implementation, use this command:

$ make hashtable_test
$ ./hashtable_test.out

To build a test_assign2_1 executable with the "-g" flag enabled in gcc for
use in gdb and valgrind to link debugging tools to the source code, use the
following recipe:

$ make debug
$ ./test_assign2_1

To remove all files generated by building and running the test programs, use
the following command:

$ make clean

2. Design
********************************************************************************

In this section, we briefly describe the design of our buffer manager.


2.1. Management Data (BM_BufferPool.mgmtData)
**************************************************

In the given data structure for a buffer pool, we were given a void pointer.
This provided the freedom to add any more useful data we may need for
our buffer pool. The struct is defined in `buffer_mgr_extra.h` as follows:

```
typedef struct BM_MgmtData {
  SM_FileHandle* fHandle;       // file handle for buffer pool page file
  BM_PageFrame* pFrames;        // list of page handles (page slots in buffer)
  int nextNewFrameIdx;          // the next free frame to be allocated in frames
  hashtable_t* frameMap;        // hashtable to map page number to frame index
  bool* dirtyFlags;             // dirty flags array
  int* fixCounts;               // fix counts array
  int* frameContents;           // pageNumbers at every index
  void* replacementData;        // struct for replacement strategy data
  int countReadIO;              // number of reads from disk
  int countWriteIO;             // number of writes to disk
} BM_MgmtData;
```

We maintain a file handle object from our storage manager to refer to the file
for which the buffer pool is opened (one file per buffer pool in our current
implementation).

We keep an array of frames (each only has the pointer to the byte data char*).

Before we've begun to use replacement strategies (i.e. when all frames have not
yet been allocated for the first time) the `nextNewFrameIdx` value keeps track
of the next frame to use for a pinned page.

We maintain a hashtable `frameMap` (interface defined by hashtable.h) to manage
mapping page numbers to frame index with efficient time complexity.

The arrays `dirtyFlags`, `fixCounts`, and `frameContents` have indices that are
semantically synchronized with the indices in `pFrames`, the array of frames in
our buffer table. These are kept separate from the frames to provide easy access
to statistics data through the `getFixCounts`, `getDirtyFlags`, and similar
functions. For example, the dirty flag for the i-th frame is stored at index-i
of the dirtyFlags array.

The properties `countReadIO` and `countWriteIO` provide statistics for
the number of read and write operations the buffer pool has had to perform.

The `replacementData` void pointer allows us to extend the management data with
any data strucure tailored to our replacement strategy. Rather than allocate
data for every strategy and only use some of it, this pointer allows us to
assign struct types that are tailored to only what is needed for a given
replacement strategy. For example, FIFO has different needs than LRU. In,
`buffer_mgr_extra.h` we define two structs:

```
typedef struct FIFO_Data {
  int fifoNextIdx;
} FIFO_Data;

typedef struct LRU_Data {
  int counter;
  int* lastUsed;
} LRU_Data;
```

Therefore, if the strategy is LRU, we allocate heap memory for LRU_Data and
save the pointer to void pointer `replacementData`. That way, we only allocate
what we need for the LRU eviction policies. Likewise, this data is dynamically
freed in our `shutdownBufferPool` function.

2.2. Hashtable Overview
**************************************************

Our simplified hashtable is defined in `header.h` and implemented in
`hashtable.c`. Because of it's simplicity in some ways, to call it a
"hashtable" is admittedly a misnomer. This lookup table is simplified for
mapping pageNumbers (keys that are integers >= 0) to indices (values that are
integers >= 0). These constraints allow us to use values like "-1" as error
indicator (e.g. `hashtable_get` cannot find a value mapped to a given key so it
returns a -1 value);

We've only implemented init, destroy, put, get, and remove as
these are the only functions needed for our buffer pool implementation.

Most notably, our lookup table implementation lacks a hash function. When
considering sequential lookups, we can see that collisions are low if we mod
the input page numbers themselves. We can also control the costs of collisions
with our `HASHTABLE_FACTOR` in buffer_mgr.c. This value divides the number of
pages in our buffer pool to give us the number of buckets in our hashtable.
At HASHTABLE_FACTOR = 1, each page has its own bucket and collisions won't
happen. This is similar to using an array with every index corresponding to a
page. As `HASHTABLE_FACTOR` approaches number of pages in our buffer pool,
there will be more collisions and therefore longer linked lists at each bucket
that require computation time to iterate through. This implementation uses less
memory off the bat, allocating more on the fly, while increasing time complexity.
On the other hand, having one bucket per page would yield the fastest time with
the least memory consumption at the onset of the program. Using this factor,
we can balance our resources to our liking.

2.3. Replacement Strategies
**************************************************

All eviction policies must ignore pages with a fix count greater than 0.

Our implementation allows two replacement strategies. With FIFO, the eviction
policy simply iterates and repeats through the frames array until a frame with
fixCount 0 is found. Since the eviction policy iterates through in the same order
as is placed, the first frame in will be the first one removed provided the
frame's fix count is 0 when the eviction policy selects it for eviction.

In LRU eviction, an array of integers is kept with indices synchronized with
frame index similar to how `dirtyFlags` and `fixCounts` have been implemented.
Every time a page is pinned, the corresponding index in the LRU array is given
the next incremented value of counter. When we need to select a page to evict,
we simply find the minimum in this array and evict the frame with index
corresponding to our minimum finding algorithm. This algorithm for finding the
minimum also ignores frames with fix counts greater than zero.
